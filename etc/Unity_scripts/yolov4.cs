#if ENABLE_WINMD_SUPPORT
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.AI.MachineLearning;
// using Windows.Media;
// using Windows.Storage;
// using Windows.UI.Xaml;

pubilc sealed class Model
{
    private LearningModel _model;
    private LearningModelSession _session;
    private LearningModelBinding _binding;
    private readonly string[] _labels = {"Red_fire_extinguisher",
                                         "Silver_fire_extinguisher",
                                         "exit_sign",
                                         "fire_detector",
                                         "fireplug"};

    internal struct DetectionResult
    {
        public string label;
        public List<float> bbox;
        public double prob;
    }

    class Comparer : IComparer<DetectionResult>
    {
        public int Compare(DetectionResult x, DetectionResult y)
        {
            return y.prob.CompareTo(x.prob);
        }
    }


    internal async Task InitModelAsync()
    {
        var model_file = await StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///Assets//model.onnx"));
        _model = await LearningModel.LoadFromStorageFileAsync(model_file);
        var device = new LearningModelDevice(LearningModelDeviceKind.Cpu);
        _session = new LearningModelSession(_model, device);
        _binding = new LearningModelBinding(_session);
    }


    internal async Task<List<DetectionResult>> EvaluateFrame(VideoFrame frame)
    {
        _binding.Clear();
        _binding.Bind("input_1:0", frame);
        var results = await _session.EvaluateAsync(_binding, "");

        TensorFloat result = results.Outputs["Identity:0"] as TensorFloat;
        var shape = result.Shape;
        var data = result.GetAsVectorView();
        var detections = ParseResult(data.ToList<float>().ToArray());

        Comparer cp = new Comparer();
        detections.Sort(cp);
        return NMS(detections);
    }


    // parse the result from WinML evaluation results to self defined object struct
    private List<DetectionResult> ParseResult(float[] results)
    {
        int c_values = 84;
        int c_boxes = results.Length / c_values;
        float confidence_threshold = 0.5f;
        List<DetectionResult> detections = new List<DetectionResult>();
        for (int i_box = 0; i_box < c_boxes; i_box++)
        {
            float max_prob = 0.0f;
            int label_index = -1;
            for (int j_confidence = 4; j_confidence < c_values; j_confidence++)
            {
                int index = i_box * c_values + j_confidence;
                if (results[index] > max_prob)
                {
                    max_prob = results[index];
                    label_index = j_confidence - 4;
                }
            }
            if (max_prob > confidence_threshold)
            {
                List<float> bbox = new List<float>();
                bbox.Add(results[i_box * c_values + 0]);
                bbox.Add(results[i_box * c_values + 1]);
                bbox.Add(results[i_box * c_values + 2]);
                bbox.Add(results[i_box * c_values + 3]);

                detections.Add(new DetectionResult()
                {
                    label = _labels[label_index],
                    bbox = bbox,
                    prob = max_prob
                });
            }
        }
        return detections;
    }

    // Non-maximum Suppression(NMS), a technique which filters the proposals 
    // based on Intersection over Union(IOU)
    private List<DetectionResult> NMS(IReadOnlyList<DetectionResult> detections,
        float IOU_threshold = 0.45f,
        float score_threshold = 0.3f)
    {
        List<DetectionResult> final_detections = new List<DetectionResult>();
        for (int i = 0; i < detections.Count; i++)
        {
            int j = 0;
            for (j = 0; j < final_detections.Count; j++)
            {
                if (ComputeIOU(final_detections[j], detections[i]) > IOU_threshold)
                {
                    break;
                }
            }
            if (j == final_detections.Count)
            {
                final_detections.Add(detections[i]);
            }
        }
        return final_detections;
    }

    // Compute Intersection over Union(IOU)
    private float ComputeIOU(DetectionResult DRa, DetectionResult DRb)
    {
        float ay1 = DRa.bbox[0];
        float ax1 = DRa.bbox[1];
        float ay2 = DRa.bbox[2];
        float ax2 = DRa.bbox[3];
        float by1 = DRb.bbox[0];
        float bx1 = DRb.bbox[1];
        float by2 = DRb.bbox[2];
        float bx2 = DRb.bbox[3];

        Debug.Assert(ay1 < ay2);
        Debug.Assert(ax1 < ax2);
        Debug.Assert(by1 < by2);
        Debug.Assert(bx1 < bx2);

        // determine the coordinates of the intersection rectangle
        float x_left = Math.Max(ax1, bx1);
        float y_top = Math.Max(ay1, by1);
        float x_right = Math.Min(ax2, bx2);
        float y_bottom = Math.Min(ay2, by2);

        if (x_right < x_left || y_bottom < y_top)
            return 0;
        float intersection_area = (x_right - x_left) * (y_bottom - y_top);
        float bb1_area = (ax2 - ax1) * (ay2 - ay1);
        float bb2_area = (bx2 - bx1) * (by2 - by1);
        float iou = intersection_area / (bb1_area + bb2_area - intersection_area);

        Debug.Assert(iou >= 0 && iou <= 1);
        return iou;
    }

}
#endif